# v8.0.0 Hierarchical Memory System Design

## Problem Statement

Current memory-keeper stores raw transcripts that grow to 3.8GB+ with:
- Useless metadata (queue-operation, file-history-snapshot, etc.)
- Full tool results (entire file contents)
- Thinking blocks (internal reasoning)
- No hierarchical summarization
- facts.json barely used (10 entries despite months of work)

## Solution: 4-Layer Hierarchical Memory

```
L4 (Surface)   : Keywords + Permanent Memories  → Fast lookup, long-term retention
       ↑
L3 (Concepts)  : Feature/Topic summaries        → "REST/SLEEP system", "AP mechanics"
       ↑
L2 (Exchanges) : Per-interaction summaries      → "Fixed REST button bug in ui.js:42"
       ↑
L1 (Deep)      : Refined raw content            → User/assistant text + tool summaries
```

---

## L1: Refined Raw Content

### Goal
Reduce 20MB raw.jsonl → 500KB-1MB (95% reduction)

### Keep
| Type | Content |
|------|---------|
| user | Full text |
| assistant | Full text |
| tool | Name + target + diff summary + result |

### Remove
- `queue-operation` (internal)
- `file-history-snapshot` (internal)
- `thinking` (internal reasoning)
- `parentUuid`, `sessionId`, `messageId`, etc. (metadata)

### Format
```jsonl
{"ts":"2026-01-05T01:42:00Z","role":"user","text":"Fix REST button logic"}
{"ts":"2026-01-05T01:42:05Z","role":"assistant","text":"I'll fix the REST button logic."}
{"ts":"2026-01-05T01:42:10Z","role":"tool","name":"Read","target":"scripts/ui.js","lines":"1-50","result":"ok"}
{"ts":"2026-01-05T01:42:15Z","role":"tool","name":"Edit","target":"scripts/ui.js:42","diff":"-if (day > last)\n+if (day > last && !rest_used)","result":"ok"}
{"ts":"2026-01-05T01:42:20Z","role":"assistant","text":"Fixed. REST button now works once per day."}
```

### Implementation
- `refine-raw.js` script processes raw.jsonl on session end
- Extracts meaningful content, discards junk
- Stores as `sessions/YYYY-MM-DD_HHMM.l1.jsonl`

---

## L2: Exchange Summaries

### Goal
Summarize each user request → resolution cycle

### Structure
```json
{
  "id": "e001",
  "ts": "2026-01-05T01:42:00Z",
  "summary": "Fixed REST button daily limit bug",
  "details": "Found missing rest_used check in scripts/ui.js:42, added condition to prevent multiple clicks per day",
  "files": ["scripts/ui.js"],
  "keywords": ["REST", "button", "daily limit", "bug fix"],
  "l1_range": [15, 28]
}
```

### Generation
- **Trigger**: Session end or every 5 tool uses
- **Method**: LLM reads L1, generates summary
- **Storage**: `sessions/YYYY-MM-DD_HHMM.l2.json`

### L1 Reference
`l1_range: [15, 28]` means lines 15-28 in corresponding L1 file

---

## L3: Concept Summaries

### Goal
Group related L2 exchanges into feature/topic concepts

### Structure
```json
{
  "id": "c001",
  "name": "REST/SLEEP Button System",
  "summary": "Daily usage limit system with AP recovery. Multiple bug fixes: rest_used check, date reset logic, duplicate click prevention",
  "exchanges": ["e001", "e003", "e007", "e015"],
  "files": ["scripts/ui.js", "scripts/state.js"],
  "keywords": ["REST", "SLEEP", "AP", "daily limit"],
  "updated": "2026-01-09"
}
```

### Classification (Hybrid)
1. **Rule-based extraction**: Files touched, keywords from L2
2. **LLM decision**: Given existing L3 list + new L2 data:
   - If file/keyword overlap > 30%: Add to existing concept
   - Otherwise: Create new concept

### Storage
- `concepts.json` in memory folder
- Updated on each L2 generation

---

## L4: Permanent Memory (facts.json)

### Goal
Long-term retention of important information

### Auto-Record Triggers

| Trigger | Condition | Example |
|---------|-----------|---------|
| **User explicit** | "Remember this", "Always do X", "From now on" | "Ignore ESLint warnings" |
| **Repeated solution** | Same issue 10+ times, then fixed | Variable proliferation → single variable |
| **Breakthrough** | Multiple failures then success | REST button logic → rest_used flag |
| **Core logic** | Project core feature changes | AP system restructure |

### Self-Correction
```json
{
  "id": "p005",
  "content": "Use camelCase for variable names",
  "confidence": 0.8,
  "contradictions": 0,
  "last_validated": "2026-01-09"
}
```

- Track `contradictions`: Actions that contradict this memory
- If contradictions >= 5: Request LLM review
- If wrong: Delete or correct

### Structure
```json
{
  "keywords": {
    "REST": ["c001", "e001", "e003"],
    "AP": ["c001", "c003"],
    "CSS": ["c002"]
  },
  "permanent": {
    "rules": [
      {
        "id": "r001",
        "content": "ESLint warnings can be ignored in this project",
        "source": "user",
        "confidence": 1.0
      }
    ],
    "solutions": [
      {
        "id": "s001",
        "problem": "Variable proliferation with chatIndex",
        "solution": "Use single variables instead of chatIndex-based names",
        "attempts": 12,
        "confidence": 0.95
      }
    ],
    "core_logic": [
      {
        "id": "cl001",
        "feature": "AP System",
        "description": "Removed ap_max, overflow allowed, sleep_recovery replaces max",
        "files": ["scripts/state.js"]
      }
    ]
  },
  "stats": {
    "total_exchanges": 150,
    "total_concepts": 12,
    "last_updated": "2026-01-11"
  }
}
```

---

## File Structure

```
.claude/memory/
├── facts.json              # L4: Keywords + Permanent memories
├── concepts.json           # L3: Concept summaries
├── memory.md               # Human-readable summary (deprecated → L3)
├── project.md              # Project description
└── sessions/
    ├── 2026-01-11_0042.raw.jsonl    # Original (can delete after L1)
    ├── 2026-01-11_0042.l1.jsonl     # L1: Refined content
    └── 2026-01-11_0042.l2.json      # L2: Exchange summaries
```

---

## Migration Path

1. **v8.0.0**: Implement L1 refinement
   - New sessions create L1 alongside raw
   - Existing raw files can be batch-processed

2. **v8.1.0**: Implement L2 generation
   - LLM generates summaries on session end
   - Add l2.json files

3. **v8.2.0**: Implement L3 concepts
   - Build concepts.json from L2 data
   - Deprecate memory.md

4. **v8.3.0**: Implement L4 automation
   - Auto-detect triggers
   - Self-correction system

---

## Expected Results

| Metric | Before | After |
|--------|--------|-------|
| Storage per session | 17-20MB | 500KB-1MB (L1) + 5KB (L2) |
| facts.json entries | 10 | 100+ (auto-generated) |
| Search speed | Slow (grep 3.8GB) | Fast (L4 keywords → L3 → L2 → L1) |
| Context quality | Low (raw dump) | High (hierarchical summaries) |

---

## Implementation Priority

1. L1 refinement (immediate storage savings)
2. L2-L3 hierarchical summarization
3. L4 automation and self-correction