# v9.0.0 Design: Claude-Based L2-L3-L4 Implementation

## Background

사용자 피드백에 따르면 현재 L2-L3-L4 구현이 실질적으로 사용 불가능한 상태:
- L2: auto-l2.js가 첫 100자만 복붙 → 의미없는 요약
- L3: 빈 배열 버그 + 단순 30% overlap → 모든 exchange가 별도 concept
- L4: auto-trigger 작동 안함, self-correction 작동 안함, keywords index 비어있음

## Design Goals

1. **Claude 기반 처리**: 현재 Claude 세션이 모든 요약/분류 담당
2. **Haiku 모델 사용**: 요약/분류 작업은 가능하면 Haiku 모델로 (비용/속도 최적화)
3. **실질적 가치**: 검색/참조 시 실제로 유용한 정보 제공
4. **기존 호환성**: memory.md 및 facts.json 유지

## Model Selection

L2/L3/L4 요약 및 분류 작업에 **Haiku 모델 우선 사용**:
- Task tool에서 `model: "haiku"` 파라미터 사용
- 간단한 요약/분류 작업에 적합
- 비용 절감 + 속도 향상

복잡한 판단이 필요한 경우에만 기본 모델 사용:
- self-correction (모순 검토)
- 복잡한 concept 병합 결정

---

## Part 1: Bug Fixes

### 1.1 utils.js - cwd 폴더 생성 버그

**문제**: `getProjectDir()`가 잘못된 위치에 `.claude/memory` 폴더 생성

**수정**:
```javascript
function getProjectDir() {
  // 현재 작업 디렉토리의 .claude/memory 사용
  // 단, 이미 존재하는 경우에만 (생성하지 않음)
  const cwd = process.cwd();
  const memoryDir = path.join(cwd, '.claude', 'memory');

  // 존재 여부만 확인, 자동 생성 안함
  if (fs.existsSync(memoryDir)) {
    return memoryDir;
  }

  // fallback: 스크립트 위치 기준
  return path.join(__dirname, '..', '.claude', 'memory');
}
```

### 1.2 facts.json 구조 호환성

**문제**: 새 구조와 기존 구조 간 호환성 문제

**수정**: `loadFacts()`에서 구조 자동 감지 및 마이그레이션
```javascript
function loadFacts() {
  const facts = readJsonOrDefault(factsPath, {});

  // 구버전 구조 감지 및 변환
  if (facts.decisions && !facts.rules) {
    return migrateOldStructure(facts);
  }

  // 기본 구조 보장
  return {
    rules: facts.rules || [],
    solutions: facts.solutions || [],
    coreLogic: facts.coreLogic || [],
    keywordsIndex: facts.keywordsIndex || {},
    ...facts
  };
}
```

### 1.3 calculateOverlap 빈 배열 처리

**문제**: 빈 배열이면 무조건 0 반환 → 새 concept 생성

**수정**:
```javascript
function calculateOverlap(arr1, arr2) {
  // 둘 다 비어있으면 같은 것으로 취급하지 않음 (새로 생성)
  if (!arr1?.length && !arr2?.length) return 0;

  // 한쪽만 비어있으면 매칭 불가
  if (!arr1?.length || !arr2?.length) return 0;

  // 정상 계산
  const set1 = new Set(arr1.map(s => s.toLowerCase()));
  const set2 = new Set(arr2.map(s => s.toLowerCase()));
  const intersection = [...set1].filter(x => set2.has(x));
  return intersection.length / Math.min(set1.size, set2.size);
}
```

---

## Part 2: L2 - Haiku-Based Exchange Summaries

### 2.1 현재 문제

`auto-l2.js`:
```javascript
// 현재: 첫 100자 복붙
const mainRequest = userRequests[0] || 'Session work';
summary: mainRequest.substring(0, 80)
```

### 2.2 새 설계

**Stop hook에서 Claude에게 요약 요청:**

```
[MEMORY_KEEPER] Session ended. Please generate L2 summary:

For each significant exchange in this session, provide:
{
  "exchanges": [{
    "id": "e001",
    "summary": "1문장 요약 (무엇을 했는지)",
    "details": "구체적 내용 (어떻게, 왜)",
    "files": ["수정된 파일들"],
    "keywords": ["검색용 키워드 3-5개"],
    "outcome": "success|partial|failed"
  }]
}

Output JSON only, no explanation.
```

**Claude 응답 파싱 및 저장:**
```javascript
// counter.js final() 수정
function promptL2Generation() {
  const prompt = `[MEMORY_KEEPER] Generate L2 summary for this session...`;

  // Claude가 JSON 응답하면 파싱
  // 실패 시 fallback으로 auto-l2.js 사용 (개선된 버전)
}
```

### 2.3 memory.md 동시 업데이트

L2 생성 시 memory.md에도 추가:
```javascript
function updateMemoryMd(l2Data, sessionId) {
  const memoryPath = path.join(getProjectDir(), 'memory.md');
  const existing = fs.existsSync(memoryPath)
    ? fs.readFileSync(memoryPath, 'utf8')
    : '';

  const newEntry = formatL2ForMemory(l2Data, sessionId);
  fs.writeFileSync(memoryPath, existing + '\n' + newEntry);
}
```

---

## Part 3: L3 - Haiku-Based Concept Grouping

### 3.1 현재 문제

```javascript
// 현재: 단순 30% overlap
const fileOverlap = calculateOverlap(files, concept.files);
const keywordOverlap = calculateOverlap(keywords, concept.keywords);
const score = (fileOverlap + keywordOverlap) / 2;
```

→ 의미 기반 분류 불가, garbage concept 이름

### 3.2 새 설계

**L2 생성 직후 Claude에게 분류 요청:**

```
[MEMORY_KEEPER] Classify this exchange into concepts:

New exchange:
- Summary: "사용자 인증 JWT 구현"
- Keywords: ["jwt", "auth", "login"]
- Files: ["auth.js", "middleware.js"]

Existing concepts:
1. c001: "인증 시스템" - keywords: ["auth", "session"]
2. c002: "API 엔드포인트" - keywords: ["api", "routes"]

Decision:
A) Merge into existing concept (specify which)
B) Create new concept (provide name)

Output format:
{
  "action": "merge|create",
  "conceptId": "c001",  // if merge
  "conceptName": "새 개념 이름",  // if create
  "reason": "분류 이유"
}
```

### 3.3 Concept 이름 생성

Claude가 의미 기반으로 이름 생성:
- 기존: `userRequests[0].substring(0, 80)` → "fix the bug in..."
- 신규: Claude가 `"버그 수정 - 로그인 리다이렉트"` 같은 명확한 이름 생성

---

## Part 4: L4 - Haiku-Based Permanent Memory (with Sonnet fallback)

### 4.1 현재 문제

- auto-trigger 작동 안함 (LLM 없이 패턴 매칭만)
- self-correction 구현만 있고 실제 작동 안함
- keywords index 비어있음

### 4.2 새 설계: Auto-Extraction

**세션 중 Claude가 자동 판단:**

```
[MEMORY_KEEPER] Check if this should be permanent memory:

Exchange summary: "PostgreSQL 대신 MongoDB 사용 결정"
Details: "문서 기반 데이터가 많아서 MongoDB가 더 적합"

Is this worth remembering permanently?
- Rule (항상 적용되는 규칙)?
- Solution (반복되는 문제 해결)?
- Core Logic (핵심 로직 변경)?

Output:
{
  "shouldSave": true|false,
  "type": "rule|solution|coreLogic|none",
  "content": "저장할 내용",
  "keywords": ["검색용 키워드"],
  "confidence": 0.8
}
```

### 4.3 Keywords Index 자동 구축

모든 L4 항목에서 keywords 추출하여 인덱스 구축:

```javascript
function updateKeywordsIndex(facts) {
  const index = {};

  // rules에서 추출
  for (const rule of facts.rules) {
    for (const kw of rule.keywords || []) {
      if (!index[kw]) index[kw] = [];
      index[kw].push({ type: 'rule', id: rule.id });
    }
  }

  // solutions, coreLogic도 동일하게
  // ...

  facts.keywordsIndex = index;
  saveFacts(facts);
}
```

### 4.4 Self-Correction

**모순 감지 시 Claude가 검토:**

```javascript
function checkContradiction(newRule, existingRules) {
  // 키워드 겹침 + 내용 상충 감지
  const related = existingRules.filter(r =>
    hasKeywordOverlap(newRule.keywords, r.keywords)
  );

  if (related.length > 0) {
    // Claude에게 검토 요청
    const prompt = `
[MEMORY_KEEPER] Potential contradiction detected:

New rule: "${newRule.content}"
Existing rules:
${related.map(r => `- ${r.content}`).join('\n')}

Are these contradictory?
{
  "isContradiction": true|false,
  "resolution": "keep_new|keep_old|merge",
  "mergedContent": "병합된 내용"  // if merge
}
`;
    // Claude 응답에 따라 처리
  }
}
```

---

## Implementation Order

### Phase 1: Bug Fixes
1. utils.js - getProjectDir() 수정
2. facts.json - 구조 호환성 추가
3. update-concepts.js - calculateOverlap 수정

### Phase 2: L2 Improvements
4. counter.js final() - L2 프롬프트 추가
5. 새 파일: scripts/parse-l2-response.js
6. memory.md 동시 업데이트

### Phase 3: L3 Improvements
7. counter.js - L3 분류 프롬프트 추가
8. update-concepts.js - Claude 기반 분류 로직

### Phase 4: L4 Improvements
9. counter.js - L4 auto-extraction 프롬프트
10. utils.js - keywords index 구축
11. counter.js - self-correction 로직

---

## File Changes Summary

| File | Changes |
|------|---------|
| scripts/utils.js | getProjectDir() 수정, keywords index 함수 |
| scripts/counter.js | final() L2/L3/L4 프롬프트, self-correction |
| scripts/update-concepts.js | calculateOverlap 수정, Claude 기반 분류 |
| scripts/parse-l2-response.js | 새 파일: Claude 응답 파싱 |

---

## Backwards Compatibility

- memory.md: 유지 (L2에서 동시 업데이트)
- facts.json: 자동 마이그레이션
- 기존 L1 파일: 그대로 사용
- 기존 세션 파일: 호환

---

## Success Criteria

1. L2 요약이 실제로 의미있는 내용 포함
2. L3 concept이 의미 기반으로 그룹화
3. L4 permanent memory가 자동으로 축적
4. keywords 검색이 실제로 작동
5. self-correction이 모순 감지 시 작동
